# Домашнее задание №6
0. Подготовка
- Развернута ВМ Ubuntu Server 22.04.

![](HW6_img/1.png)

- Установлен PostgreSQL 15.
 
1.	Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.

![](HW6_img/2.png)

> Необходимо перезагрузить PostgreSQL для применения настройки.
Создадим таблицу "person_test" и заполним ее какими-то данными.

![](HW6_img/3.png)

В новой сессии выключаем автокоммит, обновляем одну из строк таблицы "person_test":

![](HW6_img/4.png)

Получаем:

![](HW6_img/5.png)

> В таблице "person_test" теперь стоит блокировка RowExclusiveLock.
> <br> Также появился реальный идентификатор транзакции transactionid на котором удерживается блокировка ExclusiveLock.
> <br> Такой идентификатор появляется у каждой транзакции, потенциально меняющей состояние базы данных.

Выполняем коммит во второй сессии и получаем в первой:

![](HW6_img/6.png)

2. Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.
Будем использовать запрос:

  ```
  select lock.locktype, lock.relation::regclass, lock.mode, lock.transactionid as tid, lock.virtualtransaction as vtid, lock.pid, lock.granted
  from pg_catalog.pg_locks lock
  left join pg_catalog.pg_database db on db.oid = lock.database
  where not lock.pid = pg_backend_pid()
  order by lock.pid;
  ```

Во второй сессии выполним обновление строки id = 1:

![](HW6_img/7.png)

В первой сессии видим возникшие блокировки:

![](HW6_img/8.png)

В третьей сессии выполним обновление строки id = 1:

![](HW6_img/9.png)

В первой сессии видим возникшие блокировки:

![](HW6_img/10.png)

В четвертой сессии выполним обновление строки id = 1:

![](HW6_img/11.png)

В первой сессии видим:

![](HW6_img/12.png)

> 1925 (вторая сессия) блокирует строку таблицы, 2114 (третья сессия) ожидает 1925, а 2192 (четвертая сессия) ожидает 2114.
> <br> Каждый сеанс держит эксклюзивные (ExclusiveLock) блокировки на номера своих транзакций (transactionid) и виртуальной транзакции (virtualxid)
> <br> Вторая сессия (1925) захватила эксклюзивную блокировку строки (RowExclusiveLock) для строки с id = 1.
> <br> Третья (2114) и четвертая (2192) сессии также повесили RowExclusiveLock на строку. Кроме того, данные сессии повесили экслоюзивную блокировку на сам кортеж, т.к. хотят обновить именно его, но он уже обновлен во второй сессии.
> <br> Оставшаяся блокировка ShareLock вызванна тем, что мы пытаемся обновить строку, на которой уже есть RowExclusiveLock.

Выполним коммит во второй сессии, получаем:

![](HW6_img/13.png)

Выполним коммит в третьей сессии, получаем:

![](HW6_img/14.png)

Выполним коммит в четвертой сессии, получаем:

![](HW6_img/15.png)

3. Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?
Создадим табличку "product_test" и наполним ее различными данными:

![](HW6_img/16.png)

Убедимся, что блокировок нет:

![](HW6_img/17.png)

В первой сессии выполним обновление строки id = 1:

![](HW6_img/18.png)

Просмотрим блокировки:

![](HW6_img/19.png)

Во второй сессии выполним обновление строки id = 2:

![](HW6_img/20.png)

Просмотрим блокировки:

![](HW6_img/21.png)

В третьей сессии выполним обновление строки id = 3:

![](HW6_img/22.png)

Просмотрим блокировки:

![](HW6_img/23.png)

Далее в первой сессии выполним обновление строки id = 2:

![](HW6_img/24.png)

Просмотрим блокировки:

![](HW6_img/25.png)

Во второй сессии выполним обновление строки id = 3:

![](HW6_img/26.png)

Просмотрим блокировки:

![](HW6_img/27.png)

В третьей сессии выполним обновление строки id = 1:

![](HW6_img/28.png)

Просмотрим блокировки:

![](HW6_img/29.png)

> Третья сессия поймала "deadlock", т.к. она ожидала первую и вторую, а вторая сессия при этом ждала третью, т.е. мы попали в бесконечный цикл (кольцо).

Выполняем «rollback» в третьей сессии.
Во второй делаем коммит:

![](HW6_img/30.png)

Просмотрим блокировки:

![](HW6_img/31.png)

В первой сессии делаем коммит и смотрим результат:

![](HW6_img/32.png)

Просмотрим блокировки:

![](HW6_img/33.png)

Смотрим журнал:
   ```
   tail -n 20 /var/log/postgresql/postgresql-15-main.log
   ```

![](HW6_img/34.png)

> Читая лог, можем разобраться в последовательности операций, приведшей к блокировке.

## Задание со звездочкой*
4. Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга? Попробуйте воспроизвести такую ситуацию.
Убедимся, что блокировок в базе нет:

![](HW6_img/35.png)

Создадим таблицу с текстовым полем и заполним случайно сгенерированными данными в размере 1млн строк:

![](HW6_img/36.png)

Начнем в обеих сессиях транзакцию, выполнив команду «begin;».
В первой сессии выполним заполнение поля «n» номером строки, отсортировав записи в порядке возрастания:

![](HW6_img/37.png)

Во второй сессии выполним заполнение поля «n» номером строки, отсортировав записи в порядке убывания:

![](HW6_img/38.png)

Первая сессия отваливается:

![](HW6_img/39.png)

Просмотрим блокировки:

![](HW6_img/40.png)

Смотрим журнал:

![](HW6_img/42.png)

> Ошибку ловим в момент "пересечения" двух запросов.
> <br> Пыталась "поймать" ошибку при малом наборе данных в таблице, но апдейт в первой сессии заканчивался раньше, чем доходило до места "пересечения" запросов.
